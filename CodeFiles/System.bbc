#bf "sleep" "void" "int";

#bf "int-to-float" "float" "int";
#bf "float-to-int" "int" "float";

using System.Console;

[Define("boolean")]
enum bool
{
    False = 0,
    True = 1,
}

char DigitToChar(int digit)
{
      if (digit == 0) { return '0'; }
      elseif (digit == 1) { return '1'; }
      elseif (digit == 2) { return '2'; }
      elseif (digit == 3) { return '3'; }
      elseif (digit == 4) { return '4'; }
      elseif (digit == 5) { return '5'; }
      elseif (digit == 6) { return '6'; }
      elseif (digit == 7) { return '7'; }
      elseif (digit == 8) { return '8'; }
      elseif (digit == 9) { return '9'; };  
}

char DigitToChar(byte digit)
{
      if (digit == 0) { return '0'; }
      elseif (digit == 1) { return '1'; }
      elseif (digit == 2) { return '2'; }
      elseif (digit == 3) { return '3'; }
      elseif (digit == 4) { return '4'; }
      elseif (digit == 5) { return '5'; }
      elseif (digit == 6) { return '6'; }
      elseif (digit == 7) { return '7'; }
      elseif (digit == 8) { return '8'; }
      elseif (digit == 9) { return '9'; };  
}

export String ToString(this bool v)
{
    if (v) { return "true"; }
    else { return "false"; };
}

export String ToString(this byte number)
{
	String result = new String(0);

	if (number == 0) {
	      delete result;
	      result = "0";
	      return result;
	};

	byte v = number;

	while (v > 0)
	{
        byte rem = v % 10;
		
		String newResult = new String(result.length + 1);
		CopyString(result, newResult);
		newResult[result.length] = DigitToChar(rem);
		delete result;
		result = newResult;

		v = v / 10;
	};

	String reversed = result.Reverse();
	delete result;
	result = reversed;

	return result;
}

export String ToString(this int number)
{
	if (number == 0) {
	    return "0";
	};
    
	String result = new String(0);

	int v = number;

	bool isNegative = v < 0;
	if (isNegative)
	{ v = 0 - v; };

	while (v > 0)
	{
        int rem = v % 10;
		
		String newResult = new String(result.length + 1);
		CopyString(result, newResult);
		newResult[result.length] = DigitToChar(rem);
		delete result;
		result = newResult;

		v = v / 10;
	};

    if (isNegative)
    {
        String newResult = new String(result.length + 1);
		CopyString(result, newResult);
        newResult[result.length] = '-';
        delete result;
        result = newResult;
    };

	String reversed = result.Reverse();
	delete result;
	result = reversed;

	return result;
}

[External("sleep")]
export void Sleep(int ms);

export int Pow(int a, int b)
{
    if (b == 0) { return 1; };
    if (b < 0)
    { return 1 / Pow(a, Abs(b)); };
    int answer = 1;
    for (int i = 1; i <= b; i++)
    { answer = answer * a; };
    return answer;
}

export int Abs(int v)
{
    if (v < 0) { return v * -1; };
    return v;
}
  
export int Min(int a, int b)
{
    if (a < b) { return a; };
    return b;
}

export int Max(int a, int b)
{
    if (a > b) { return a; };
    return b;
}

export String Substring(this String v, int start)
{
    int newLength = 0;
    for (int i = start; i < v.length; i++)
    {
        newLength++;
    };
    String newV = new String(newLength);
    for (int i = start; i < v.length; i++)
    {
        newV[i - start] = v[i];
    };
    return newV;
}

export String Reverse(this String v)
{
    String newV = new String(v.length);
    for (int i = 0; i < v.length; i++)
    {
        newV[i] = v[v.length - 1 - i];
    };
    return newV;
}

export String Substring(this String v, int start, int length)
{
    String newV = new String(Min(v.length, start + length));
    for (int i = start; i < Min(v.length, start + length); i++)
    {
        newV[i - start] = v[i];
    };
    return newV;
}

export int ParseInt(String v)
{
    bool IsNegative = (v[0] == '-');
    String parsing = v;
    if (IsNegative) { parsing = parsing.Substring(1); };
    parsing = parsing.Reverse();
    int result = 0;
    for (int i = 0; i < parsing.length; i++)
    {
        char digit = parsing[i];
        result += (Pow(10, i) * ParseDigit(digit));
    };
    if (IsNegative)
    { result *= -1; };
    return result;
}

export byte ParseByte(String v)
{
    bool IsNegative = (v[0] == '-');
    String parsing = v;
    if (IsNegative) { parsing = parsing.Substring(1); };
    parsing = parsing.Reverse();
    int result = 0;
    for (int i = 0; i < parsing.length; i++)
    {
        char digit = parsing[i];
        result += (Pow(10, i) * ParseDigit(digit));
    };
    if (IsNegative)
    { result *= -1; };
    return result;
}

int ParseDigit(char digit)
{
    if (digit == '0') { return 0; }
    elseif (digit == '1') { return 1; }
    elseif (digit == '2') { return 2; }
    elseif (digit == '3') { return 3; }
    elseif (digit == '4') { return 4; }
    elseif (digit == '5') { return 5; }
    elseif (digit == '6') { return 6; }
    elseif (digit == '7') { return 7; }
    elseif (digit == '8') { return 8; }
    elseif (digit == '9') { return 9; };
}

[External("int-to-float")]
export float ToFloat(this int v);

[External("float-to-int")]
export int ToInt(this float v);

[Define("string")]
class String
{
    int length;

    export constructor(int length)
    {
        int pointer = Alloc(sizeof(String) + length);

        *pointer = length;

        for (int offset; offset < length; offset++)
        {
            *(pointer + sizeof(String) + offset) = '\0';
        };

        return pointer as String;
    }

    export clone(String other)
    {
        String result = new String(other.length);
        for (int i; i < other.length; i++)
        {
            result[i] = other[i];
        };
        return result;
    }

    export String +(String a, String b)
    {
        int al = a.length;
        int bl = b.length;

        int lengthSum = al + bl;

        String result = new String(lengthSum);
  
        for (int i; i < al; i++)
        {
            result[i] = a[i];
        };
  
        for (int i; i < bl; i++)
        {
            result[al + i] = b[i];
        };

        delete a;
        delete b;

        return result;
    }
    
    export String +(String a, int b)
    {
        return a + b.ToString();
    }
    
    export String +(int a, String b)
    {
        return a.ToString() + b;
    }
    
    export bool ==(String a, String b)
    {
        int length = a.length;

        if (length != b.length) { return false; };

        for (int i = 0; i < length; i++)
        {
            char _a = a[i];
            char _b = b[i];
            
            if (_a != _b)
            {
                return false;
            };
        };

        return true;
    }
    
    export char indexer_get(int index)
    {
        if (index < 0 || index >= this.length)
        { throw "Index out of range exception"; };
        return *((&this) + sizeof(String) + index);
    }
    
    export void indexer_set(int index, char element)
    {
        if (index < 0 || index >= this.length)
        { throw "Index out of range exception"; };
        *((&this) + sizeof(String) + index) = element;
    }

    export destructor()
    {
        delete &this;
    }
}

export void CopyString(String from, String to)
{
    int newLength = Min(from.length, to.length);
    for (int i; i < newLength; i++)
    {
        to[i] = from[i];
    };
}

export int Random(int state)
{
	// Precomputed parameters for Schrage's method
	int M = 0x7fffffff;
	int A = 48271;
	int Q = M / A;    // 44488
	int R = M % A;    //  3399

	int div = state / Q;	// max: M / Q = A = 48,271
	int rem = state % Q;	// max: Q - 1     = 44,487

	int s = rem * A;	// max: 44,487 * 48,271 = 2,147,431,977 = 0x7fff3629
	int t = div * R;	// max: 48,271 *  3,399 =   164,073,129
	int result = s - t;

	if (result < 0)
    { result += M; };
    
	return result;
}

void memcp(int source, int destination, int size)
{
    for (int offset; offset < size; offset++)
    {
        (*(destination + offset)) = *(source + offset);
    };
}
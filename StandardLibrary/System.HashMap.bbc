using Primitives;
using System.Memory;

inline int hash(int v)
{
    return v;
}

inline int hash(float v)
{
    return v as int;
}

int hash(string v)
{
#if IL
    int hash = 181;
    int index = 0;
    char c = v[index];

    while (c)
    {
        hash = ((hash << 5) + hash) + c;
        index++;
        c = v[index];
    }

    return hash;
#else
    int hash = 181;
    char c = v[0];

    while (c)
    {
        hash = ((hash << 5) + hash) + c;
        v = ((v as int) + sizeof(char)) as string;
        c = v[0];
    }

    return hash;
#endif
}

inline u8 equals(int a, int b)
{
    return a == b;
}

inline u8 equals(float a, float b)
{
    return a == b;
}

u8 equals(string a, string b)
{
    if (a == b) return (u8)1;
    if (a == 0 || b == 0) return (u8)0;
    int i = 0;
    while (1)
    {
        if (a[i] != b[i]) return (u8)0;
        if (a[i] == (char)0) break;
        i++;
    }
    return (u8)1;
}

struct Pair<TKey, TValue>
{
    TKey key;
    TValue value;

    Pair<TKey, TValue>*(TKey key, TValue value)
    {
        this.key = key;
        this.value = value;
    }
}

struct HashMap<TKey, TValue>
{
    private int _capacity;
    private int _length;
    private Pair<TKey, TValue>*[]* _ptr;

    export inline void indexer_set(TKey key, TValue value)
    {
        this.add(key, value);
    }

    export TValue indexer_get(temp TKey key)
    {
        TValue result;
        if (!this.get(temp key, &result)) crash "key isn't present in the hashmap";
        return result;
    }

    void ensure_capacity(int capacity)
    {
        if (this._capacity >= capacity) return;

        int newCapacity = this._capacity * 2;
        if (!newCapacity) newCapacity = 4;

        var old = this._ptr;

        this._ptr = new Pair<TKey, TValue>*[newCapacity]*;
        this._length = 0;
        this._capacity = newCapacity;

        if (old)
        {
            for (int i = this._capacity - 1; i >= 0; i--)
            {
                if (old[i]) this.add_noresize(old[i].key, old[i].value);
            }
            delete old;
        }
    }

    export u8 get(temp TKey key, TValue* value)
    {
        if (!this._ptr)
        {
            return (u8)0;
        }

        int hash = hash(key);
        int i = hash % this._capacity;
        int started = i;

        while (this._ptr[i])
        {
            if (equals(this._ptr[i].key, key))
            {
                *value = this._ptr[i].value;
                return (u8)1;
            }

            i++;
            if (i >= this._capacity) i = 0;
            if (started == i) break;
        }

        return (u8)0;
    }

    export u8 add(TKey key, TValue value)
    {
        this.ensure_capacity(this._length + 1);
        this.add_noresize(key, value);
    }

    u8 add_noresize(TKey key, TValue value)
    {
        if (!this._ptr)
        {
            crash "Map not initialized";
        }

        int hash = hash(key);
        int i = hash % this._capacity;

        while (this._ptr[i])
        {
            i++;
            if (i >= this._capacity) i = 0;
        }

        this._ptr[i] = new Pair<TKey, TValue>*(key, value);
        this._length++;
    }

    export u8 remove(temp TKey key)
    {
        int hash = hash(key);
        int i = hash % this._capacity;
        int started = i;

        while (this._ptr[i])
        {
            if (equals(this._ptr[i].key, key))
            {
                this._ptr[i] = 0;
                this._length--;
                return (u8)1;
            }

            i++;
            if (i >= this._capacity) i = 0;
            if (started == i) break;
        }

        return (u8)0;
    }

    export destructor()
    {
        if (this._ptr)
        {
            for (int i = this._capacity - 1; i >= 0; i--)
            {
                if (this._ptr[i]) delete this._ptr[i];
            }
            delete this._ptr;
        }
    }
}

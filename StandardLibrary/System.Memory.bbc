#if BRAINFUCK
alias BlockHeader u8;
const BlockHeader StatusFlag = 0x80;
const BlockHeader SizeMask = 0x7f;
#else
alias BlockHeader u32;
const BlockHeader StatusFlag = 0x80000000;
const BlockHeader SizeMask = 0x7fffffff;
#endif

alias bool u8;

const int HeapSize = 127;
const int HeaderSize = sizeof(BlockHeader);

const bool true = (bool)1;
const bool false = (bool)0;

#if BRAINFUCK
#else
*0 = (BlockHeader)HeapSize;
#endif

export void GetHeader(BlockHeader* headerPtr, int* size, bool* allocated)
{
    BlockHeader header = *headerPtr;
    if (header >= StatusFlag) // value & StatusFlag
    {
        *size = (int)(header - StatusFlag); // value & SizeMask
        *allocated = true;
    }
    else
    {
        *size = (int)header;
        *allocated = false;
    }
}

export inline void SetHeaderUsed(BlockHeader* headerPtr, int size)
{
    *headerPtr = (BlockHeader)size + StatusFlag;
}

export inline void SetHeaderFree(BlockHeader* headerPtr, int size)
{
    *headerPtr = (BlockHeader)size;
}

bool JoinFreeBlocks()
{
    BlockHeader* headerPointer = 0 as BlockHeader*;
    int prevBlockSize = 0;
    while (headerPointer < HeapSize)
    {
        int blockSize;
        bool blockUsed;
        GetHeader(headerPointer, &blockSize, &blockUsed);

        if (headerPointer != 0 && blockUsed == false)
        {
            BlockHeader* prevOffset = (headerPointer - prevBlockSize - HeaderSize) as BlockHeader*;

            int _temp;
            bool prevBlockUsed;
            GetHeader(prevOffset, &_temp, &prevBlockUsed);

            if (prevBlockUsed == false)
            {
                SetHeaderFree(prevOffset, blockSize + prevBlockSize + HeaderSize);
                *headerPointer = (BlockHeader)0;
                return true;
            }
        }

        prevBlockSize = blockSize;

        headerPointer += blockSize + HeaderSize;
    }
    return false;
}

[Builtin("alloc")]
export any* Alloc(int sizeNeed)
{
    if (sizeNeed <= 0) { crash 0; }

    BlockHeader* headerPointer = 0 as BlockHeader*;
    while (true)
    {
        if (headerPointer >= HeapSize) { crash 0; }

        int blockSize;
        bool blockUsed;
        GetHeader(headerPointer, &blockSize, &blockUsed);
        any* dataPointer = (headerPointer + HeaderSize) as any*;

        if (blockUsed == false)
        {
            if (blockSize == sizeNeed)
            {
                SetHeaderUsed(headerPointer, sizeNeed);

                return dataPointer;
            }

            if (blockSize > sizeNeed)
            {
                int _remainingSize = blockSize - sizeNeed - HeaderSize;

                if (_remainingSize > 0)
                {
                    SetHeaderFree((dataPointer + sizeNeed) as BlockHeader*, _remainingSize);
                }
                else
                {
                    sizeNeed = blockSize;
                }

                SetHeaderUsed(headerPointer, sizeNeed);

                return dataPointer;
            }
        }

        headerPointer += blockSize + HeaderSize;
    }
    return 0 as any*;
}

[Builtin("free")]
export void Dealloc(any* pointer)
{
    BlockHeader* headerPtr = (pointer as int - HeaderSize) as BlockHeader*;

    int size;
    bool allocated;

    GetHeader(headerPtr, &size, &allocated);

    if (allocated == false)
    { return; }

    SetHeaderFree(headerPtr, size);

    while (JoinFreeBlocks()) { }
}

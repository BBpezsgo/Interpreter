alias BlockHeader u8;
alias bool u8;

const byte StatusFlag  = 0b_1_0000000;
const byte SizeMask = 0b_0_1111111;
const byte MaxHeapSize = 0b_0_1111111;
const int HeaderSize = sizeof(BlockHeader);

const bool true = (bool)1;
const bool false = (bool)0;

#if BRAINFUCK
#else
*0 = MaxHeapSize;
#endif

export void GetHeader(BlockHeader* headerPtr, int* size, bool* allocated)
{
    BlockHeader header = *headerPtr;
    if (header >= StatusFlag) // value & StatusFlag
    {
        *size = (int)(header - StatusFlag); // value & SizeMask
        *allocated = true;
    }
    else
    {
        *size = (int)header;
        *allocated = false;
    }
}

export void SetHeaderUsed(BlockHeader* headerPtr, int size)
{
    BlockHeader header = (BlockHeader)size;
    header += StatusFlag; // value |= (byte)StatusFlag
    *headerPtr = header;
}

export void SetHeaderFree(BlockHeader* headerPtr, int size)
{
    *headerPtr = (BlockHeader)size;
}

bool JoinFreeBlocks()
{
    BlockHeader* headerPointer = 0 as BlockHeader*;
    int prevBlockSize = 0;
    while (headerPointer < (int)MaxHeapSize)
    {
        int blockSize;
        bool blockUsed;
        GetHeader(headerPointer, &blockSize, &blockUsed);

        if (headerPointer != 0 && blockUsed == 0)
        {
            BlockHeader* prevOffset = (headerPointer - (int)prevBlockSize - HeaderSize) as BlockHeader*;

            int temp;
            bool prevBlockUsed;
            GetHeader(prevOffset, &temp, &prevBlockUsed);

            if (prevBlockUsed == 0)
            {
                SetHeaderFree(prevOffset, blockSize + prevBlockSize + HeaderSize);
                *headerPointer = (BlockHeader)0;
                return true;
            }
        }

        prevBlockSize = blockSize;

        headerPointer += blockSize + HeaderSize;
    }
    return false;
}

[Builtin("alloc")]
export any* Alloc(int sizeNeed)
{
    if (sizeNeed == 0)
    {
        crash "What";
    }

    BlockHeader* headerPointer = 0 as BlockHeader*;
    while (true)
    {
        if (headerPointer >= (int)MaxHeapSize) { crash "Out of memory"; }

        int blockSize;
        bool blockUsed;
        GetHeader(headerPointer, &blockSize, &blockUsed);
        any* dataPointer = (headerPointer + HeaderSize) as any*;

        if (blockUsed == 0)
        {
            if (blockSize == sizeNeed)
            {
                SetHeaderUsed(headerPointer, sizeNeed);

                return dataPointer;
            }

            if (blockSize > sizeNeed)
            {
                SetHeaderUsed(headerPointer, sizeNeed);

                BlockHeader* nextHeaderPointer = (dataPointer + sizeNeed) as BlockHeader*;

                int _remainingSize = blockSize - sizeNeed - HeaderSize;

                if (_remainingSize >= 0)
                {
                    SetHeaderFree(nextHeaderPointer, _remainingSize);
                }

                return dataPointer;
            }
        }

        headerPointer += blockSize + HeaderSize;
    }
    return 0 as any*;
}

[Builtin("free")]
export void Dealloc(any* pointer)
{
    BlockHeader* headerPtr = (pointer as int - HeaderSize) as BlockHeader*;

    int size;
    bool allocated;

    GetHeader(headerPtr, &size, &allocated);

    if (allocated == 0)
    { return; }

    SetHeaderFree(headerPtr, size);

    while (JoinFreeBlocks()) { }
}

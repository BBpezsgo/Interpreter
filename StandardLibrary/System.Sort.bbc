using Primitives;

/*
 * Source: https://en.wikipedia.org/wiki/Quicksort
 */
export inline void quicksort<T>(T[]* array, int length)
{
    quicksort(array, 0, length - 1);
}

/*
 * Source: https://en.wikipedia.org/wiki/Quicksort
 */
export void quicksort<T>(T[]* array, int left, int right)
{
    if (left >= 0 && left < right)
    {
        int p = partition(array, left, right);
        quicksort(array, left, p);
        quicksort(array, p + 1, right);
    }
}

/*
 * Source: https://en.wikipedia.org/wiki/Quicksort
 */
int partition<T>(T[]* array, int left, int right)
{
    T pivot = array[left];
    int i = left - 1;
    int j = right + 1;

    while (1)
    {
        i++;
        while (array[i] < pivot) i++;

        j--;
        while (array[j] > pivot) j--;

        if (i >= j) return j;

        T _temp1 = array[i];
        array[i] = array[j];
        array[j] = _temp1;
    }
}

/*
 * Source: https://en.wikipedia.org/wiki/Insertion_sort
 */
export void insertsort<T>(T[]* values, int length)
{
    int i = 1;
    while (i < length)
    {
        T x = values[i];
        int j = i;
        while (j > 0 && values[j - 1] > x)
        {
            values[j] = values[j - 1];
            j = j - 1;
        }
        values[j] = x;
        i = i + 1;
    }
}

inline int iLeftChild(int i) { return 2 * i + 1; }

export void heapsort<T>(T[]* values, int length)
{
    int start = length / 2;
    int end = length;
    while (end > 1)
    {
        if (start > 0) // (Heap construction)
        {
            start--;
        }
        else // Heap extraction
        {
            end--;
            T t = values[end];
            values[end] = values[0];
            values[0] = t;
        }
   
        // The following is siftDown(values, start, end)
        int root = start;
        while (iLeftChild(root) < end)
        {
            int child = iLeftChild(root);
            // If there is a right child and that child is greater
            if (child+1 < end && values[child] < values[child+1])
            {
                child++;
            }

            if (values[root] < values[child])
            {
                T t = values[root];
                values[root] = values[child];
                values[child] = t;
                root = child; // repeat to continue sifting down the child now
            }
            else
            {
                break; // return to outer loop
            }
        }
    }
}

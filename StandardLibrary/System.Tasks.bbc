using Primitives;
using System.List;
using System.Memory;

struct PCB
{
    i32 _bp;
    i32 _ip;
    i32 _sp;
}

struct Task
{
    any* _stack;
    bool _yielded;
    PCB _pcb;
    void(Task*) _work;
    void(Task*) _callback;
}

export void SwitchContext(PCB* pcb)
{
    EAX = pcb._bp;
    EBX = pcb._sp;
    ECX = pcb._ip;

    BP = EAX;
    SP = EBX;
    IP = ECX;
}

temp List<Task>* _tasks = new List<Task>*(8);

export void Schedule(void(Task*) task)
{
    Task _task = new Task;
    _task._work = task;
    _task._stack = new byte[256]*;
    _tasks.add(_task);
}

export void Schedule(void(Task*) task, void(Task*) callback)
{
    Task _task = new Task;
    _task._work = task;
    _task._callback = callback;
    _task._stack = new byte[256]*;
    _tasks.add(_task);
}

bool RunNext()
{
    int length = _tasks.length();
    if (length == 0) { return false; }
    Task task = _tasks[0];

    if (task._yielded)
    {
        task._yielded = false;
        SwitchContext(&task._pcb);
    }
    else
    {
        ECX = &task as i32;
        EDX = task._work as i32;
        SP = task._stack as i32 + 255;
        BP = SP;
        IP = EDX + 1;
        // ((void(Task*))EDX)(ECX as Task*);
    }

    _yield:

    if (task._yielded) return true;

    delete task._stack;
    _tasks.remove(0);
    if (task._callback) Schedule(task._callback);
    return true;
}

export void Run()
{
    while (RunNext()) { }
}

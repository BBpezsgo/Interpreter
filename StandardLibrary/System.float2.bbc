using Primitives;
using System.Math;
using System.Vectors;

export struct float2
{
    float x;
    float y;

    export float2(float x, float y)
    {
        this.x = x;
        this.y = y;
    }
}

export void tofloat2(byte2* a, float2* b)
{
    int _x = (int)a.x;
    int _y = (int)a.y;
    if (_x > 127) { _x = -256 + _x; }
    if (_y > 127) { _y = -256 + _y; }
    b.x = (f32)_x;
    b.y = (f32)_y;
}

export float distance(float2 a, float2 b)
{
    float dx = a.x - b.x;
    float dy = a.y - b.y;
    return sqrt((dx * dx) + (dy * dy));
}

export float distancesqr(float2 a, float2 b)
{
    float dx = a.x - b.x;
    float dy = a.y - b.y;
    return (dx * dx) + (dy * dy);
}

export inline float dot(float2 a, float2 b)
{
    return (a.x * b.x) + (a.y * b.y);
}

export inline float cross(float2 a, float2 b)
{
    return a.x * b.y - a.y * b.x;
}

export inline float length(this float2 v)
{
    return sqrt((v.x * v.x) + (v.y * v.y));
}

export inline float length(this float2* v)
{
    return sqrt((v.x * v.x) + (v.y * v.y));
}

export float2 normalise(this float2 v)
{
    float d = v.length();
    v.x /= d;
    v.y /= d;
    return v;
}

export void normalise(float2* v)
{
    float d = v.length();
    v.x /= d;
    v.y /= d;
}

export void rotate(float2* v, f32 angle)
{
    f32 tx = v.x;
    v.x = v.x * cos(angle) - v.y * sin(angle);
    v.y = tx * sin(angle) + v.y * cos(angle);
}

export float2 rotate(float2 v, f32 angle)
{
    return new float2(
        v.x * cos(angle) - v.y * sin(angle),
        v.x * sin(angle) + v.y * cos(angle)
    );
}

export inline float2 +(float2 a, float2 b) { return new float2(a.x + b.x, a.y + b.y); }
export inline float2 -(float2 a, float2 b) { return new float2(a.x - b.x, a.y - b.y); }

export inline float2 *(float2 a, float b) { return new float2(a.x * b, a.y * b); }
export inline float2 /(float2 a, float b) { return new float2(a.x / b, a.y / b); }

export inline float2 +(float2 v) { return new float2(+v.x, +v.y); }
export inline float2 -(float2 v) { return new float2(-v.x, -v.y); }
